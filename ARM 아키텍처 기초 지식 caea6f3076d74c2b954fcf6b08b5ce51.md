# ARM 아키텍처 기초 지식

## 익셉션 벡터 테이블

전원이 켜지면 AR은 익셉션 벡터 테이블의 리셋 벡터(0x000000000)를 읽는다. 위치 조정을 할 수 있기는 한데 굳이 할 필요는 없다. 

익셉션은 총 7개가 있다. 이에 정의된 예외 상황이 발생하면 프로그램 카운터(PC)를 익셉션 벡터 테이블에 정의 된 오프셋 주소로 강제 변환하고, 테이블에 입력한 명령을 바로 실행함. 

테이블에 있는 익셉션은 4바이트씩 할당되어 있는데, 명령어 크기가 4바이트인 ARM에서는 익셉션 한 번에 한 가 지 명령어만 실행할 수 있다. 

ㄴ 아니 왜요? 예외 상황 처리하려면 명령어가 꽤 많이 필요할 텐데 고작 한 개 쓸 용량으로 됨? 

ㄴ 왜냐면 ARM 아키텍처는 개발자마다, 시스템마다, 펌웨어마다 익셉션 처리에 필요한 코드의 양이 다를 것이기 때문에 **효율적인 메모리 할당을 위해서 최소 명령어 용량에다가 익셉션을 처리하는 코드로 점프하게 만드는 브랜치 명령어를 써놓는 방식을 채택**했기 때문이다. 이 익셉션을 처리하는 코드를 **익셉션 핸들러**라고 부른다.

---

## 익셉션

- 익셉션이란? : **주변장치 등에서 발생한 신호를 처리하기 위해 순차적으로 진행하던 프로그램의 수행을 끊는 것을 말함. 예외 라고도 부름.**
- 익셉션 처리를 하는 건 하는 건데 문제는 R0~R14까지의 레지스터 값은 실행 중인 코드에서 값이 깨지지 않아야 하는데 익셉션이 발생하면 그런건 ㅈ까고 익셉션 벡터를 거쳐서 익셉션 핸들러로 무조건 들어간다면서 값이 죄다 깨진다는 것이다.
- 그래서 이런 불미스러운 사태가 터지지 않도록 익셉션 핸들러를 처리하고 나서도 프로그램이 망가지지 않으면서 제대로 동작할 수 있도록 작업을 해줘야하는데 ARM은 이를 위해 프로그램 흐름이 다시 원래 위치로 복귀할 수 있도록 하드웨어 수준에서 최소한의 작업을 해준다.

→ **그것은 바로 R14(LR, 링크 레지스터)에 복귀할 주소를 자동으로 저장하는 것!**

- 예를 들어서 USR 모드에서 익셉션이 발생해서 IRQ 모드로 바뀐다면 ARM은 익셉션 핸들러 직후에 자동으로 R14_irq에 저장된 값을 이용해서 USR 원래 흐름으로 건너 뛰어서 복귀할 수 있는 것이다!
- 다만 ARM의 파이프라인 때문에(?) 각 익셉션 별로 정상 복귀를 하기 위해서는 R14 값에 각기 다른 연산을 해줘야함. 근데 파이프라인이랑 뭔 상관이지?

---

## 인터럽트

- **프로그램의 흐름을 가로채는 것, 외부 요인에 의해서 발생함.** (버튼 누름, 액정 스크린 터치, 터미널에서 뭐 돌아가는거 컨트로 씨 누르면 중단되는거 등등, 근데 사실 사용자가 뭐 안 해도 그냥 1ms씩 시간 흐르면서 계속 발생함. 자세한건 타이머 참조.)
- 필연적으로 인터럽트 지연을 발생시킴, (하드웨어가 인터럽트를 감지해서 ARM에 인터럽트 신호가 입력되는 순간부터 펌웨어에서 인터럽트 핸들러가 수행되기 전까지 걸리는 시간)

### 인터럽트 순서

1. 인터럽트 발생
2. 익셉션 처리 동작 수행
3. IRQ or FRQ 익셉션 벡터로 Program Counter 변경

### 인터럽트 종류

1. IRQ (Interrupt Request) FRQ 보다 우선순위가 낮아서 동시에 발생시 나중에 처리됨. 
2. FIQ (Fast Interrupt Request) : 익셉션 동작 모드가 별도로 R8부터 R12까지 레지스터를 갖고 있기 때문이라는데.  펌웨어에서 인터럽트 처리할 때 R8에서 R12까지 사용할 땐 코드 작성시 레지스터 백업하고 복구하는 시간을 사용 안해도 돼서 그만큼 빨라진다고 함. 이걸 전문용어로 컨텍스트 스위칭 오버헤드를 줄인다고 함
3. NMFI (Non Maskable Fast Interrupt) 를 활성화 시키면 FIQ를 비활성화 시킬 수 없음. 이는 CPSR라는 것의 F비트를 0으로 클리어하는데, 이게 1이 되는 경우는 FIQ 익셉션이 발생했거나 리셋 익셉션이 발생했을 경우 뿐이다.
4. LIL(Low Interrupt Latency) 는 인터럽트 지연을 줄이기 위한 기능 중 하나. SCTLR 21번째 비트인 FI비트로 동작여부를 알 수 있음. 항상 1로 설정됨. 인터럽트가 실행되면 기존 실행 중인 명령의 실행이 아직 안 끝나도 그냥 취소해버리고 인터럽트를 먼저 처리함. 그리고 취소된 명령어는 인터럽트 핸들러의 처리가 모두 끝나면 원래 프로세스로 복귀할 때 SUBP, r14, #4로 인터럽트가 발생했던 시점에서 한 명령어 뒤로 다시 돌아가도록 해서 처리함. 사실상 인터럽트 처리를 하기 위해 같은 명령어를 두 번 실행한다는 뜻.

ARM 은 메모리 타입을 strongly ordered로 설정 가능, 

이렇게 설정된 메모리나 장치는 읽기, 쓰기 동작을 수행한 순서 및 횟수를 보장해야함. 

⇒ 메모리 접근을 시작한 후에는 수행이 끝날 때까지 실행을 멈출 수 없음. 그리고 AXI로 연결된 주변 장치도 이와 동일히 동작, 

⇒ 그러니 인터럽트 지연 시간을 최소화하기 위해서는 strongly ordered로 설정된 것들에 대해서는 멀티워드 로드/스토어 명령을 사용하지 말것

---

### VIC(Vectored Interrupt Controller)

: 인터럽트 처리를 전답하는 일종의 주변장치. ARM에는 인터럽트를 감지하는 핀이 IRQ랑 FIQ 딱 두개 뿐이라서 인터럽트가 발생했다는 것만 알 수 있지만 어떤 인터럽트가 어떤 하드웨어에서 발생했는지는 알 수 없음. 그래서 이 **인터럽트 컨트롤러**가 필요한 것임. 

---

### 인터럽트 컨트롤러의 기능

1. 인터럽트가 발생했을 때 해당 인터럽트의 종류를 레지스터에 기록함.
2. 인터럽트가 발생했을 때 ARM의 IRQ 혹은 FIQ에 맞춰서 인터럽트 신호를 줌.
3. 특정 인터럽트를 골라서 Masking 할 수 있음. 그러면 비활성화 되는데 인터럽트 컨트롤러 종류에 따라서 활성화되는 경우도 있음. 그건 각자 메뉴얼 보고 알아서 사용할 것. 
4. 여러 인터럽트 간에 우선 순위를 설정할 수도 있음! 

### 인터럽트 서비스 루틴

- 인터럽트 핸들러의 하위 개념.
- 인터럽트 핸들러에서 인터럽트 종류를 판별한 다음 해당 인터럽트만 정답으로 처리하는 코드로 이동
- 이 코드가 바로 인터럽트 서비스 루틴.

인터럽트 발생시 펌웨어는 인터럽트 서비스 루틴으로 진입함.

1. 인터럽트 컨트롤러에서 인터럽트 소스가 어떤 것인지 판별 (타이머인가? 버튼인가?)
2. 인터럽트 소스에 따라 실행해야 할 인터럽트 서비스 루틴을 선택
3. 해당 인터럽트 소스를 비활성화하고 인터럽트 서비스 루틴으로 진입. 
    
    

VIC는 위 세 단계를 하드웨어에서 처리한 다음 인터럽트에 대해서 인터업트 서비스 루틴의 시작 메모리 주소를 직접 저장함. (주소는 펌웨어가 정함, 함수 포인터를 하드웨어가 직접 가지고 있음)

⇒ **인터럽트가 발생하면 이런 과정을 거쳐서 VIC에 의해 인터럽트 서비스 루틴으로 Program Count 값이 바로 바뀌는 것이다!**

---

### Abort

- 어디서 문제가 일어났는가에 대한 보고 대신 프로그램의 동작이 더 이상 진행되지 않도록 하는 것이다.
- 앞서 말한 인터럽트 처럼 익셉션의 한 종류로 정의되어 있음.
- 인터럽트가 데이터 처리를 위해서 정상적인 프로그램의 흐름을 끊는 익셉션이라면 abort는 비정상적인 동작으로 정상적인 프로그램의 진행을 더 이상 진행할 수 없을 때 발생하는 익셉션
1. MPU(Memory Protection Unit)으로 보호되는 메모리 영역에 권한 없이 접근했을 때
2. AMBA (System on Chip의 주변장치 연결 및 관리를 위한 공개 표준) 메모리 버스가 에러를 응답했을 때 
3. ECC(Error Corrrecting Code) 로직에서 에러가 발생했을 때

ARM이 메모리에서 임의의 정보를 읽는 경우는 명령어랑 데이터 읽는 거 딱 두 가지 경우 뿐인데 전자에서 abort가 일어나면 prefetch abort고 후자는 data abort라고 한다.

근데 다른 것들은 다 정상인데 읽어 온 명령어가 ARM이 모르는 거면 undefinded instruction 익셉션인데 이것도 일종의 abort임. 이것도 오류긴 한데 익셉션 핸들러로 진입했을 때 이를 통하여 ARM에서 지원하지 않는 명령어를 처리를 하면서 소프트웨어적으로 기능을 확장시켜 나갈 수도 있음. 또한 코프로세서(co-processor)라는 보조 프로세서 하드웨어를 연결하여 기능을 확장할 수도 있다. 익셉션 핸들러에서 처리못한 명령어를 여따 보내서 처리결과를 리턴하면 그 결과를 펌웨어가 이용하는 식

---

## 동작 모드_뱅크드 레지스터

ARM에는 익셉션과 관련하여 동작모드라는게 있음.

특정 인셉션이 특정 동작 모드에 연결되어 있기도하고 익셉션과 상관없이 존재하는 동작 모드도 있음.

1. User 모드 (USR) 일반적으로 사용하는 모드, ARM상태, Thumb상태로 나뉨, 대체로 이 모드로 동작함.
2. Fast Interrupt 모드 : FIQ 모드로 전환됨, ARM 상태일 때만 동작함. 빠른 처리를 위하여 별도의 레지스터 (R8~R12)를 더 가지고 있음. 이를 뱅크드 레지스터라고 함. 
3. Interrupt 모드 (IRQ) - IRQ모드로 전환됨. ARM 상태든 Thumb상태든 둘 다 동작 가능
4. Supervisor 모드 - 운영체제 등에서 시스템 코드를 수행하기 위한 보호 모드, OS에서 시스템 콜 호출-SVC 익셉션 발생시켜 SVC 모드로 전환 - 커널 동작 수행. SCV 익셉션은 메모리나 하드웨어에 상관없이 순수하게 소프트웨어에 의해서 발생하는 익셉션
5. Abort 모드 (ABT) Data abort나 Prefetch abort가 발생했을 때 전환되는 동작 모드
6. System 모드(SYS) 운영체제 등에서 사용자 프로세스가 임시로 커널 모드를 획득해야 할 때 SYS 모드를 사용. (여기서 커널 모드란 유저 모드랑은 대비되게 모든 자원(CPU, 메모리, 드라이버 등)에 대한 접근 권한을 가지는 상태를 뜻함) 유저 모드랑 커널 모드를 구분하지 않는 운영체제라면 SYS모드가 기본 동작모드인 경우가 많음. 참고로 프로세스가 진행되는 도중에도 프로세스는 유저모드와 커널모드를 왔다갔다하면서 실행이 됨.
7. Undefined 모드(UND) Undefined instruction이 발생했을 때 진입하는 동작모드

- ARM 은 작업 레지스터를 총 37개 가지고 있는데 32비트 범용 레지스터 31개와 상태 레지스터 6개로 구성됨.
- 37개 있다고 항상 동시에 다 쓰는건 아니고 동작 모드마다 사용할 수 있는 레지스터가 다름.
- 동작 모드별로 사용할 수 있는 레지스터의 최대 개수는 정해져 있는데 범용 레지스터 16개와 상태 레지스터 2개임. 근데 동작 모드는 7종류 있으니 존나 모자라서 일부 레지스터는 여러가지 모드가 공유해서 사용해야함. 상태 레지스터도 마찬가지임.
- 각 동작 모드별로 직접 접근 가능한 레지스터는 R0~R15까지와 CPSR이 있음.

### 범용 레지스터(R0~R12)

- 펌웨어가 데이터를 일반적으로 처리할 때 사용하는 레지스터

### 특수 목적 레지스터 (R13, R14,R15)

**R13 : 스택 레지스터(SP)** 정말 특이한 예외의 경우 아니고서야 대부분의 소프트웨어들은 스택을 기반으로 동작한다. 그래서 소프트웨어는 항상 스택의 위치를 알아내야함. 이 역할을 하는 레지스터가 SP임. 스택에 데이터를 PUSH하거나 POP할 때 스택 포인터 값만 알고 있으면 그 값을 증가시키거나 감소시키면서 관리 가능

**R14: 링크 레지스터 (LR)** 마찬가지로 대부분의 소프트웨어는 서브 루틴 호출 혹은 함수 호출로 구성됨. C언어처럼 함수가 함수를 호출하고 리턴하는걸 반복하는 시스템을 기반으로 기능을 수행하는 것처럼, 함수의 호출 지점으로 돌아하는 그 위치를 **리턴 어드레스**라고 부르는데 그걸 저장하는 레지스터가 LR임. ARM은 여러 종류의 분기 명령어로 서브 루틴으로 점프하는데 그 때 ARM은 하드웨어가 자동으로 LR에다 리턴 어드레스를 넣어줌

**R15 : 프로그램 카운터 (PC)** 프로그램은 메모리에 명령어를 읽어서 실행, 그리고 그 다음 명령어를 읽어서 실행하는 것의 반복인데 그럼 지금거 실행하고 다음에 실행할 명령어의 메모리 주소를 저장하고 있어야 하는데 분기 명령어가 처리 되면 PC는 분기로 점프하고 기존의 주소는 LR에 저장된다. ARM모드일때는 명령어 한 개가 처리되고 나면 4바이트 증가하고 Thumb 모드일때는 2바이트 증가한다. (명령어의 크기가 ARM모드일때는 32bit, Thumb모드일때는 16bit 이기 때문.)

FIQ 모드의 R8부터 R12까지는 FIQ 모드에서만 쓸 수 있게 배정되어 있기 때문에 이 영역은 이전의 해당 값을 백업할 필요가 없음. FIQ가 빠른 이유 중 하나.

개별 동작 모드는 모두 **SP와 LR을 뱅크드 레지스터로 가지고 있음**. 그래야 각 동작 모드가 독립된 스택 영역을 유지할 수 있고(SP) 각각 다른 모드들에게 영향을 받지 않으면서 다른 동작 모드로 원활하게 복귀할 수 있는 것이다. (LR)

각 동작 모드에서 전용으로 사용하는 레지스터는 이름은 같을지라도 실제로도 독립된 공간에 데이터를 저장함. 이런 레지스터를 **뱅크드 레지스터**라고 부름

뱅크드 레지스터는 각 동작 모드별로 **SP, LR, SPSR(프로그램 상태 레지스터)** 가 있음.

## ARM과 Thumb 란?

똑같은 C 언어 코드를 각각 ARM모드, Thumb모드로 컴파일 해보면 결과로 생성되는 바이너리의 크기가 각자 다름. 명령어 크기가 다르니까 대강 절반쯤 안될까 싶지만 실제로 보면 70프로쯤 된다고 함. 그거면 어디냐 싶긴한데 펌웨어의 목적에 따라 크기보다 속도가 더 중요한 경우도 많아서 ARM에서는 크기는 크지만 속도는 빠른 ARM과 속도는 느리지만 크기는 작은 Thumb를 적재적소에 섞어서 씀. 

참고로 Thumb 모드에서는 R8이상의 높은 번호 레지스터 사용이 제한됨. SP, LR, PC만 사용할 수 있고 R8에서 R12까지의 범용 레지스터는 몇 가지 명령어에서만 사용 가능

## 프로그램 상태 레지스터

앞서 말한 프로세서의 상태 외에도 프로그램이 동작하면서 생기는 많은 상태가 있음. 예를 들면 계산 결과가 음수이거나 0일때 이것을 상태로 가지고 있어야 수행할 수 있는 동작이 있음. 이런 상태들을 관리하는 레지스터를 **프로그램 상태 레지스터**라고 함. 

CPSR (Current PSR) : 현재 상태 저장하는 레지스터

SPSR (Saved PSR) : 상태를 저장하는 레지스터 (즉, CPSR의 백업본이라고 볼 수 있음! 그래서 구조가 똑같음)