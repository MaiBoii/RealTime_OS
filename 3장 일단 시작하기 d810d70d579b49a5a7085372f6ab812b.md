# 3장: 일단 시작하기

## 컴파일러

- 펌웨어를 만들려면 해당 시스템에 맞는 컴파일러를 사용해야한다. 따라서 컴파일을 실행하는 환경과 컴파일의 결과물이 실행될 다른 경우에 사용하는 컴파일러를 **크로스 컴파일러**(Cross-Compiler)라고 한다.
- 따라서 우리는 x86 말고도 많은 환경을 지원하는 **GCC**를 사용할 것임.

## QEMU

- x86, ARM 등 여러 환경을 가상 머신으로 사용할 수 있는 에뮬레이터이다. 비싼 ARM 개발보드 대신 사용할 수 있다! 정말 제대로 배워야겠다면 개발보드 직접 하나 사보는 것도 좋은 선택이겠지만 일단 지금은 이걸로 해보자. 우리 수준에선 이것도 충분히 차고 넘친다.

## 리셋 벡터

- ARM 코어에 전원이 들어가서 가장 먼저 하는 일이 **리셋 벡터**(0x000000000)에 있는 32비트 짜리 명령을 읽어와 실행하는 일이다.
- 리셋 벡터 위치를 우리가 변경할 수도 있기는 한데 굳이 해서 좋을건 없다. 본인이 변태면 해도 됨.

## 소프트 웨어의 구성 요소 분류 : 기준-데이터

1. 데이터: 우리가 프로그램을 만들 때 선언하는 변수.
2. 데이터를 변경하는 코드 : 그 변수의 값을 변경하는 LOGIC.

## 실행 파일

```bash
#Entry.S

.text
	.code 32

	.global vector_start
	.global vector_end

	vector_start:
			MOV  R0, R1
	vector_end:
		.space  1024, 0
.end

```

- 소프트웨어를 구성하는 요소를 파일 시스템에 바이너리 상태로 맹글어 놓은 거.
- 위 코드를 바이너리로 변경해서 모아 놓은 영역을 실행 파일에서는 **.text섹션 이**라고 부름.
- .global 은 우리 C언어에서 사용하는 extern 함수처럼 외부 소스 파일에서 전역 변수를 가져오는 역할을 함. 이 친구 덕분에 우리는 벡터 스타트랑 벡터 엔드의 주소 정보를 외부에서 읽어 볼 수 있게 되었다!
- MOV R0, R1 은 별로 신경 쓰지 마셈. 그냥 R1 값을 R0에 넣으라는 뜻임. 본 책에서 어셈블리 종종 나오긴 하는데 이거 모른다고 진행 아예 못할만큼 중요하게 나오지는 않으니 쫄진 말 것. 모르는 명령어는 그때그때 배우면 됨.
- .space 1024, 0 → 해당 위치부터 1024 바이트를 0으로 채우라는 뜻. 그러니 MOV R0, R1 이 4바이트 크기를 할당하고 있으니 0x00000004 부터 0x00000400 까지 0으로 채워져야 한다.

## 실행 파일 만드는 과정

- 리눅스는 표준 실행 파일 형식으로 ELF 확장자를 사용함. ELF는 엘프가 아니라 Excutable and Linkable File 이라는 뜻임.
- 이름에서 나왔듯이 이 ELF 파일을 만들려면 Linker의 도움이 필요함. 사람이 쓴 코드를 컴파일해서 오브젝트 파일들을 만들어 놓으면 이것들을 다 제 위치로 묶어서 실행 파일을 만들어야하는데 이 묶는 역할을 하는 프로그램을 **링커**라고 함.
- 이 링커가 동작하려면 링커에 정보를 던져 주는 파일이 필요한데 이를 **링커 스크립트**라고 부름. 평소에 우리가 주로 쓰는 운영체제에서 애플리케이션을 만들 때는 해당 운영체제에 맞는 파일이 라이브러리에다 기본으로 포함되어 있으니 굳이 신경을 안 쓰고 살아도 됐지만 지금 우리는 아무것도 없는 상태에서 만드는 중이니 펌웨어가 동작하는 하드웨어 환경에 맞춰서 섹션 배치를 세세히 조정해야 할 필요가 생겼다. 그러니 직접 만들어 보자!

```c
//navilos.axf 링크 스크립트 만들기 

ENTRY(vector_start) //시작 위치 심벌
SECTIONS //해당 영역이 섹션 배치 설정 정보를 알려주고 있음을 뜻함.
{
	. = 0x0; //첫 번째 섹션의 메모리 주소값이 0x00000000에 위치함을 뜻함.

	.text :
	{
		*(vector_start)
		*(.text .rodata)
	}

	.data :
	{
		*(.data)
	}

	.bss :
	{
		*(.bss)
	}
}
```

## QEMU에서 실행하기

- 하지만 이렇게 링크 스크립트를 만들어 봤자 섹션 배치도 리눅스 커널에 맞지 않는데다 전용 라이브러리도 없는 상황이니 이것만으로는 실행 파일을 만들어봤자 실행이 불가능하다. 그러니 QEMU로 ARM 개발 환경을 에뮬레이팅해서 가동시켜보자!
- 근데 실행된 QEMU에다 직접 디버깅을 해봤자 아무것도 안 나올게 뻔하니 일단 화면 정지해두고 우리가 따로 디버깅은 gdb를 다운 받아서 별도의 터미널에다 원격 연결해서 하도록 하자.

## Makefile

- 프로그램 개발 시 라인이 길어지게 되면 여러개의 모듈로 나누어 개발이 진행하게 되는데 이 때 입력 파일이 바뀌게 되면 바뀐 파일과 관계가 있는 파일 또한 다시 컴파일을 해야 하는 불편함이 발생한다. 이 때 Makefile 을 만들어 빌드(실행 파일 만들기)시 불편함을 줄일 수 있다.
- 검색해 보니 이거 양식에 맞게 만드는 메뉴얼이 따로 있던데 참고하면 될 듯. [https://www.gnu.org/software/make/manual/make.html#Pattern_002dspecific-Variable-Values](https://www.gnu.org/software/make/manual/make.html#Pattern_002dspecific-Variable-Values)
- 암튼 이런거 하나 만들어 놓으면 하나 수정할 때마다 컴파일-링킹-QEMU 가동-디버깅 일일이 다 해줄 필요없이 편하게 실행파일을 빌드하고 실행해 볼 수 있다. 그냥 우리 편하자고 만든거니 너무 어려워할 건 없다.

## 하드웨어 정보 읽어오기-데이터 시트 읽는 방법

레지스터 (register)

- 하드웨어와 소프트웨어와 상호작용하는 인터페이스

데이터시트에 담긴 정보

- 해당 하드웨어가 지닌 레지스터의 목록
- 레지스터에 어떤 입력값이 들어갈 때 하드가 어떻게 작동하는지가 적힌 설명서 같은거

```c
.text
	.code 32

	.global vector_start
	.global vector_end

	vector_start:
		LDR		R0, =0x10000000 //R0에 해당 메모리 주소값을 넣어라
		LDR		R1, [R0] //R0에 저장된 메모리 주소에서 값을 읽어 R1에 넣어라
	vector_end:
		.space 1024, 0
.end
```

- 0x10000000 ← 여기에 뭐가 있길래 넣으란것인지는 우리가 QEMU로 구현한 RealviewPB의 데이터시트에서 레지스터 주소를 찾으면 ID Register라고 나온다. 이름에서부터 감이 오듯이 하드웨어를 식별할 수 있는 정보를 지닌 레지스터이고, 당연히 읽기 전용이다. 주로 펌웨어가 여러 하드웨어를 대응할 수 있도록 쓰인다. RealViewPB는 해당 레지스터의 이름을 SYS_ID라고 부른다.
- 해당 하드웨어의 데이터 시트를 확인하면 SYS_ID 의 기본값은 0x1780500이다. 이를 어떻게 확인하면 좋을까?
- 디버깅 도중 info register 로 ARM의 레지스터 상태를 확인하면 0밖에 없다. 그도 그럴 것이 그 상태에서는 실행파일이 실행되지 않았기 때문이다. 그러면 s 명령어를 통해 한 줄씩 코드를 실행시키다보면 위 실행파일 내용대로 레지스터를 채워나가는 것을 볼 수 있다. R0에 0x10000000 이 저장되어 있는 것을 알 수 있고, R1에 해당 메모리 주소를 읽어 0x1780500이 뜨는 것을 통해 거기에 있는 SYS_ID를 불러 넣은 것을 확인할 수 있다.